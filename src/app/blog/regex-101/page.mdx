import { ArticleLayout } from '@/components/ArticleLayout'
import regexDiagram from './planetaria-design-system.png'

export const article = {
    author: 'Sathya Tadinada',
    date: '2025-08-10',
    title: 'Regex Demystified: Intro to Pattern Matching',
    description:
        'Regular expressions (regex) are a powerful tool for pattern matching and text manipulation. In this article, we will explore the fundamentals of regex, its syntax, and practical applications.',
    tags: ['regex', 'tutorial', 'programming', 'theory']
}

export const metadata = {
    title: article.title,
    description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

Regular expressions (regex) have a reputation for looking like arcane symbols from a hacker movie.

```regex
^.*(?=.{6,})(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).*$
```

If that looks like keyboard mash to you, you're not alone. The truth is, regex can be complex and intimidating at first glance.
However, regex is nothing more than a language for describing patterns in text, and under the hood it works like a tiny machine that reads
your string one character at a time.

In this post, we'll walk through regex one step at a time, connect it to some computer science theory, and leave 
you with practical tips for writing patterns that you'll still be able to understand six months from now.

## What Regex Really Is

Regex isn't "code" in the same sense as a general-purpose language (like Java or Rust). It's **declarative**: you describe the shape of the text you want, and the regex engine figures out how to _find_ it.

Behind the scenes, many regex engines turn your pattern into a **finite state machine** (FSM) and step through your input, deciding "match" or "no match".

<Image src={regexDiagram} alt="State diagram for regex a(b|c)d+" />

> TL;DR: Regex describes a set of strings. The engine checks whether your input is in that set.

## The Building Blocks
Regex has only a handful of core ideas. Combine them and you can recognize surprisingly complex patterns.

### Literals
Match exact characters.

```txt
cat                         # matches "cat" in text
```

### Character Classes
Match _one_ character from a set.

```regex
[abc]                       # "a" or "b" or "c"
[0-9]                       # any digit
\w                          # any letter, digit, or underscore
\s                          # whitespace (space, tab, newline)
.                           # any character (except newline in many engines)
```

> Pro tip: In a class, `-` creates ranges (`[A-Z]`). To match a literal `-`, put it first or last: `[-A-Z]` or `[A-Z-]`.

### Quantifiers
Specify how many times to match the preceding element.

```regex
a+                          # one or more a's
b*                          # zero or more b's
c?                          # zero or one c
d{2,4}                      # between 2 and 4 d's
```

### Anchors and Groups
Specify positions and group sub-patterns.

```regex
^abc$                       # match exactly "abc" from start to end
(abc)                       # capture "abc" as group 1
(?:abc)                     # non-capturing group
```

### Boundaries
Control word/line boundaries.

```regex
\bword\b                    # "word" as a whole word
^line                       # start of line (with multiline flag)
line$                       # end of line (with multiline flag)
```

## Flags (aka Modifiers)
Flags change how a pattern behaves.

| Flag | Common name | Effect |
| ---- | ----------- | ------ |
| `i`  | ignore case | Case-insensitive matching |
| `m`  | multiline   | `^` and `$` match line boundaries, not just start/end of whole string |
| `s`  | dotall      | `.` also matches newlines |
| `g`  | global      | (JS) find all matches, not just the first |
| `u`  | unicode     | (JS) full Unicode mode (enables things like `\p{Letter}`) |
| `x`  | extended    | (PCRE/Python) allow whitespace/comments inside the pattern |

> Python uses inline flags like `re.IGNORECASE` or `(?i)`. JavaScript uses regex literals like `/pattern/imsu`.

## Greedy vs. Lazy
By default, quantifiers are **greedy**: they match as much as possible.

```regex
<.*>                        # greedy: "<tag>content</tag>" → one giant match
<.*?>                       # lazy: minimal match, "<tag>"
```

> If your pattern "eats" too much, try the lazy `?` variant: `*?`, `+?`, `??`, `{m,n}?`.

## Alternation & Precedence
`|` means "or". Group to control scope.

```regex
colou?r                     # "color" or "colour"
(https?|ftp)                # "http", "https", or "ftp"
```

Without parentheses, alternation applies only to the nearest pieces: `ab|cd` ≠ `a(b|c)d`.

## Capturing, Naming, and Reusing
Capturing groups let you pull data out and reuse matches.

```regex
(\d{4})-(\d{2})-(\d{2})     # year-month-day
```

Named groups (engine-specific syntax):

```regex
(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})
```

Backreferences:

```regex
<(\w+)[^>]*>.*?<\/\1>       # start/end tags must match the same name
```

> JavaScript backreference to a named group: `\k<year>`. Python: `(?P<year>...)` and `(?P=year)`.

## Lookarounds (Zero-Width Assertions)
Lookarounds assert context without consuming characters.

```regex
(?=...)                     # positive lookahead
(?!...)                     # negative lookahead
(?<=...)                    # positive lookbehind (engine support varies)
(?<!...)                    # negative lookbehind
```

Examples:

```regex
\d+(?=\sUSD)                # numbers followed by " USD"
(?<!\w)cat(?!\w)            # "cat" as a whole word (alternative to \b)
```

## Multi-Language Examples
Same idea, different APIs.

```javascript
// JavaScript
const phone = /^\(\d{3}\) \d{3}-\d{4}$/;
phone.test('(123) 456-7890'); // true
```

```python
# Python
import re
phone = re.compile(r"^\(\d{3}\) \d{3}-\d{4}$")
bool(phone.fullmatch('(123) 456-7890'))  # True
```

```rust
// Rust (regex crate)
use regex::Regex;
fn main() {
    let re = Regex::new(r"^\(\d{3}\) \d{3}-\d{4}$").unwrap();
    println!("{}", re.is_match("(123) 456-7890")); // true
}
```

```java
// Java
import java.util.regex.*;
var re = Pattern.compile("^\\(\\d{3}\\) \\d{3}-\\d{4}$");
System.out.println(re.matcher("(123) 456-7890").matches()); // true
```

> String literal escapes differ! In many languages you need to double backslashes in strings. Prefer raw strings when available (`r"..."` in Python, Rust).

## Step-by-Step Matching
Let's take `a(?:b|c)d+` and walk through matching `"acddd"`.

| Step | Current State | Read Char | Action     |
| ---- | ------------- | --------- | ---------- |
| 1    | Start         | `a`       | Match `a`  |
| 2    | After `a`     | `c`       | Match `c`  |
| 3    | After `c`     | `d`       | Match loop |
| 4    | Loop          | `d`       | Loop again |
| 5    | Loop          | `d`       | Loop again |
| 6    | End           | —         | Accept!    |

## Practical Recipes
A few patterns you can adapt.

```regex
# ISO date (YYYY-MM-DD)
^(?<year>\d{4})-(?<month>0[1-9]|1[0-2])-(?<day>0[1-9]|[12]\d|3[01])$
```

```regex
# Slug (lowercase words separated by dashes)
^[a-z0-9]+(?:-[a-z0-9]+)*$
```

```regex
# Trim from start/end (use in replace)
^\s+|\s+$
```

```regex
# Simple (not RFC-perfect) email — good enough for UI validation
^[^\s@]+@[^\s@]+\.[^\s@]+$
```

> For anything security-sensitive (like email parsing on a server), prefer a real parser over a single monstrous regex.

## Replacing Text with Captures

```javascript
// Reformat YYYY-MM-DD → DD/MM/YYYY
'2025-08-10'.replace(/(\d{4})-(\d{2})-(\d{2})/, '$3/$2/$1')
// → '10/08/2025'
```

```python
import re
re.sub(
    r"(?P<y>\d{4})-(?P<m>\d{2})-(?P<d>\d{2})", 
    r"\g<d>/\g<m>/\g<y>", "2025-08-10"
)
```

## Unicode & \p Properties
Modern engines support Unicode character classes.

```regex
\p{Letter}+         # one or more letters in any language
\p{Greek}+          # Greek letters
\p{Emoji}           # depends on engine; alternatives exist
```

> In JavaScript, use the `u` flag for Unicode escapes and categories. In Python, Unicode is default in 3.x.

## Performance: Avoiding Catastrophic Backtracking
Certain patterns can take exponential time on tricky inputs ("catastrophic backtracking"). Classic offenders combine nested quantifiers and wildcards:

```regex
^(a+)+$             # dangerous
^(.+)+$             # dangerous
```

Safer alternatives:

- Prefer explicit character classes over `.` when feasible.
- Use lazy quantifiers with anchors: `^.*?foo` instead of `^.*foo` when appropriate.
- Where supported (e.g., Java, PCRE), consider **possessive quantifiers** (`*+`, `++`, `?+`, `{m,n}+`) or **atomic groups** (`(?>...)`) to prevent backtracking.
- In Rust's `regex` crate, many problematic features (like backreferences and lookaround) are intentionally unsupported; patterns run in linear time.

## When _Not_ to Use Regex
- Parsing nested, recursive structures (HTML, JSON, source code) → use a parser/DOM/AST.
- Handling complex, locale-sensitive formats (dates, numbers) → use libraries.
- Anything where clarity and maintainability beat clever one-liners → write code.

## A Method for Writing Maintainable Regex
1. **Write the examples first**: What should match? What should not?
2. **Build in layers**: Start with literals, then introduce classes and quantifiers.
3. **Name your groups**: Future-you will thank you.
4. **Comment your pattern**: Use the "extended" flag (`x`) where available and add inline comments.
5. **Test against edge cases**: Empty strings, long strings, weird Unicode, punctuation.
6. **Benchmark if needed**: Especially for user-supplied input.

### Example with Comments (PCRE/Python `re.VERBOSE`)

```regex
^                                   # start of string
(?<area>\(\d{3}\))\s                # (123) and a space
(?<prefix>\d{3})-                   # 456-
(?<line>\d{4})                      # 7890
$                                   # end of string
```

## Mini-Exercises
Try these before peeking at the answers.

1. Match IPv4 addresses (0–255 in each octet).
2. Extract the domain from a URL.
3. Split a CSV line that allows quoted commas.

<details>
<summary>Show solutions</summary>

```regex
# 1) IPv4 (concise, not perfect but reasonable)
^(25[0-5]|2[0-4]\d|1?\d?\d)(?:\.(25[0-5]|2[0-4]\d|1?\d?\d)){3}$
```

```regex
# 2) Domain from URL (scheme optional)
^(?:https?:\/\/)?(?:www\.)?([^\/\n?#]+)
```

```regex
# 3) CSV split (use a parser in production!)
,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)
```

</details>

## Theory Corner (Short & Sweet)
- **Regular languages** are those recognized by finite automata.
- Most popular engines (PCRE, JS, Python) are **backtracking NFAs**: powerful, feature-rich, can backtrack.
- Some (like Rust's `regex`) compile to automata that execute in **linear time** by avoiding backtracking-only features.

The big idea: features like backreferences and some lookarounds make patterns more expressive than regular languages, which is why engines use richer algorithms than a pure DFA.

## Quick Reference

| Concept | Pattern | Notes |
| --- | --- | --- |
| Digit / non-digit | `\d` / `\D` | ASCII vs Unicode depends on engine/flags |
| Word char / non-word | `\w` / `\W` | includes `_` |
| Whitespace / non-space | `\s` / `\S` | space, tab, newline |
| Word boundary | `\b` | opposite: `\B` |
| Start / end | `^` / `$` | with `m`, apply per-line |
| Optional | `x?` | zero or one |
| One or more | `x+` | greedy |
| Zero or more | `x*` | greedy |
| Lazy quantifier | `x+?` | minimal |
| Exactly n | `x{n}` | repeats |
| Range | `x{m,n}` | between m and n |
| Grouping | `( ... )` | capturing |
| Non-capturing | `(?: ... )` | groups without capturing |
| Alternation | `x\|y` | either x or y |
| Lookahead | `(?=...)` / `(?!...)` | zero-width |
| Lookbehind | `(?<=...)` / `(?<!...)` | engine support varies |

## Wrap-Up
Regex is a compact way to describe patterns. Start simple, add features deliberately, and test with real data. When you need more than pattern matching, reach for a parser. When regex _is_ the right tool, the techniques above will keep your patterns readable and fast.
